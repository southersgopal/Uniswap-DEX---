# Web3æ™ºèƒ½åˆçº¦å¼€å‘æŒ‡å—ï¼šæ·±å…¥è§£æ Uniswap V2 æ ¸å¿ƒæ¶æ„ | DeFiæŠ€æœ¯ç ”ç©¶

> ğŸ’¡ æœ¬æ–‡ç”±é¢†å…ˆçš„åŒºå—é“¾æŠ€æœ¯æœåŠ¡å•† [Crypto8848](https://crypto8848.com) æŠ€æœ¯å›¢é˜Ÿå‡ºå“ã€‚æˆ‘ä»¬ä¸“æ³¨äº DeFiã€DAppã€ç®—æ³• Token ç­‰ Web3 æ ¸å¿ƒæŠ€æœ¯å¼€å‘ï¼Œæä¾›å…¨æ–¹ä½çš„åŒºå—é“¾è§£å†³æ–¹æ¡ˆã€‚Telegramï¼š[@recoverybtc](https://t.me/recoverybtc)

## Crypto8848ï¼šæ‚¨çš„ä¸“ä¸š Web3 æŠ€æœ¯åˆä½œä¼™ä¼´

ä½œä¸º Web3 æ—¶ä»£çš„æŠ€æœ¯å…ˆé©±ï¼Œ[Crypto8848](https://crypto8848.com) å§‹ç»ˆèµ°åœ¨åŒºå—é“¾æŠ€æœ¯åˆ›æ–°çš„å‰æ²¿ï¼Œæˆ‘ä»¬çš„æ ¸å¿ƒä¼˜åŠ¿åŒ…æ‹¬ï¼š

### 1. å…¨é“¾ DeFi å¼€å‘æ–¹æ¡ˆ
- æ”¯æŒä»¥å¤ªåŠã€BSCã€Solana ç­‰ä¸»æµå…¬é“¾
- æ— ç¼é›†æˆ MetaMaskã€Trust Wallet ç­‰ä¸»æµ Web3 é’±åŒ…
- è®¡ç®—å±‚ä¸æ•°æ®å±‚åˆ†ç¦»çš„é«˜æ€§èƒ½æ¶æ„è®¾è®¡
- è‡ªä¸»ç ”å‘çš„é£æ§ç³»ç»Ÿï¼Œå…¨æ–¹ä½ä¿éšœèµ„é‡‘å®‰å…¨

### 2. åˆ›æ–°å‹ DApp ä¸ DeFi è§£å†³æ–¹æ¡ˆ
- ä¸º DeFi å’Œ DAO é¡¹ç›®æä¾›ç®—æ³•æ”¯æŒ
- é€šè¿‡æ™ºèƒ½ç®—æ³•å®ç°ä»£å¸ç»æµæ¨¡å‹
- è®¾è®¡å®Œå–„çš„å»ä¸­å¿ƒåŒ–æ²»ç†æœºåˆ¶
- æ„å»ºå¯æŒç»­å‘å±•çš„ DeFi ç”Ÿæ€ç³»ç»Ÿ

### 3. Web3 æ™ºèƒ½åˆçº¦å®šåˆ¶
- å…¨é“¾æ™ºèƒ½åˆçº¦å¼€å‘æœåŠ¡
- Web2 åˆ° Web3 çš„ä¸šåŠ¡å‡çº§æ–¹æ¡ˆ
- é«˜æ€§èƒ½åˆçº¦æ¶æ„è®¾è®¡
- æ™ºèƒ½åˆçº¦å®‰å…¨æ€§ä¼˜åŒ–

### 4. ç®—æ³• Token å®šåˆ¶å¼€å‘
- ç¨³å®šå¸ç®—æ³•è®¾è®¡ä¸å®ç°
- å¼¹æ€§ä¾›åº”ä»£å¸å¼€å‘
- æ™ºèƒ½å›è´­ä¸æµåŠ¨æ€§è°ƒèŠ‚
- åˆ›æ–°å‹ä»£å¸ç»æµæ¨¡å‹è®¾è®¡

> ğŸ“¢ åŒºå—é“¾æŠ€æœ¯å’¨è¯¢ä¸æ”¯æŒï¼š
> - å®˜ç½‘ï¼š[Crypto8848.com](https://crypto8848.com)
> - Telegramï¼š[@recoverybtc](https://t.me/recoverybtc)
> - ä¸šåŠ¡èŒƒå›´ï¼šDeFiåè®®å¼€å‘ã€DAppå®šåˆ¶å¼€å‘ã€æ™ºèƒ½åˆçº¦å¼€å‘ã€ç®—æ³•ç¨³å®šå¸å¼€å‘ç­‰
> - 24/7 ä¸“ä¸šæŠ€æœ¯æ”¯æŒï¼Œæ‰“é€ æ‚¨çš„ Web3 åˆ›æ–°é¡¹ç›®

## Uniswap V2 DeFiåè®®æŠ€æœ¯è§£æ

åœ¨è¿™ä¸ªå¿«é€Ÿå‘å±•çš„ Web3 æ—¶ä»£ï¼Œæ·±å…¥ç†è§£é¡¶çº§ DeFi åè®®çš„è®¾è®¡åŸç†å¯¹äºå¼€å‘è€…æ¥è¯´è‡³å…³é‡è¦ã€‚è®©æˆ‘ä»¬ä¸€èµ·æ¢ç´¢ Uniswap V2 çš„æ ¸å¿ƒæŠ€æœ¯æ¶æ„ï¼š

### 1. è‡ªåŠ¨åšå¸‚å•†ï¼ˆAMMï¼‰æœºåˆ¶
Uniswap V2 é‡‡ç”¨æ’å®šä¹˜ç§¯åšå¸‚å•†ï¼ˆConstant Product Market Makerï¼‰æ¨¡å‹ï¼Œæ ¸å¿ƒå…¬å¼ä¸ºï¼š
```
x * y = k
```
å…¶ä¸­ï¼š
- x å’Œ y åˆ†åˆ«ä»£è¡¨æ± å­ä¸­ä¸¤ç§ä»£å¸çš„æ•°é‡
- k æ˜¯ä¸€ä¸ªå¸¸æ•°ï¼Œåœ¨æ²¡æœ‰æ‰‹ç»­è´¹çš„æƒ…å†µä¸‹ä¿æŒä¸å˜
- ä»»ä½•äº¤æ˜“éƒ½å¿…é¡»éµå¾ªè¿™ä¸ªå…¬å¼ï¼Œç¡®ä¿ k å€¼åœ¨äº¤æ˜“åä¸ä¼šå‡å°‘

### 2. ä»·æ ¼æœºåˆ¶
- ä»·æ ¼ç”±æ± å­ä¸­ä»£å¸æ•°é‡æ¯”ä¾‹è‡ªåŠ¨å†³å®šï¼šprice = x/y
- äº¤æ˜“é‡è¶Šå¤§ï¼Œæ»‘ç‚¹è¶Šå¤§ï¼Œä¿æŠ¤æ± å­å…å—ä»·æ ¼æ“çºµ
- å¥—åˆ©è€…ä¼šé€šè¿‡äº¤æ˜“ä½¿ä»·æ ¼è¶‹è¿‘äºå¸‚åœºå‡è¡¡ä»·æ ¼

### 3. æµåŠ¨æ€§æä¾›
- é¦–æ¬¡æä¾›æµåŠ¨æ€§ï¼šå¯ä»¥æŒ‰ä»»æ„æ¯”ä¾‹å­˜å…¥ä»£å¸
- åç»­æä¾›æµåŠ¨æ€§ï¼šå¿…é¡»æŒ‰ç…§å½“å‰æ± å­ä¸­çš„ä»£å¸æ¯”ä¾‹å­˜å…¥
- æµåŠ¨æ€§æä¾›è€…è·å¾— LP ä»£å¸ï¼Œä»£è¡¨å¯¹æ± å­çš„æ‰€æœ‰æƒä»½é¢
- å¼•å…¥æœ€å°æµåŠ¨æ€§é”å®šæœºåˆ¶ï¼ˆMINIMUM_LIQUIDITYï¼‰ï¼Œé˜²æ­¢é¦–æ¬¡æ·»åŠ æµåŠ¨æ€§æ—¶çš„ä»·æ ¼æ“çºµ

### 4. æ‰‹ç»­è´¹æœºåˆ¶
- æ¯ç¬”äº¤æ˜“æ”¶å– 0.3% çš„æ‰‹ç»­è´¹
- å…¶ä¸­ 0.25% åˆ†é…ç»™æµåŠ¨æ€§æä¾›è€…
- 0.05% å¯é€šè¿‡æ²»ç†æœºåˆ¶åˆ†é…ç»™åè®®ï¼ˆå¯å¼€å…³ï¼‰
- æ‰‹ç»­è´¹è‡ªåŠ¨æ·»åŠ åˆ°æµåŠ¨æ€§æ± ä¸­ï¼Œæé«˜ k å€¼

### 5. é—ªç”µè´·åˆ›æ–°
- åœ¨ä¸€ä¸ªäº¤æ˜“ä¸­ï¼Œå¯ä»¥å…ˆå€Ÿç”¨æ± å­ä¸­çš„ä»£å¸
- å¿…é¡»åœ¨äº¤æ˜“ç»“æŸå‰å½’è¿˜å€Ÿç”¨çš„ä»£å¸ï¼Œå¹¶ä¿è¯ k å€¼ä¸å‡å°‘
- ä¸ºå¥—åˆ©å’Œæ¸…ç®—ç­‰æ“ä½œæä¾›äº†æ— æŠµæŠ¼å€Ÿè´·æœºåˆ¶

### 6. ä»·æ ¼é¢„è¨€æœº
- ç´¯ç§¯ä»·æ ¼æœºåˆ¶ï¼Œè®°å½•æ¯ä¸ªåŒºå—çš„ä»·æ ¼ç´¯ç§¯å€¼
- é€šè¿‡ä¸¤ä¸ªæ—¶é—´ç‚¹çš„ç´¯ç§¯ä»·æ ¼å·®å€¼ï¼Œå¯è®¡ç®—æœŸé—´çš„æ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼ï¼ˆTWAPï¼‰
- æä¾›é˜²æ“çºµçš„é“¾ä¸Šä»·æ ¼æ•°æ®

### 7. åˆçº¦æ¶æ„
Uniswap V2 ç”±ä¸‰ä¸ªæ ¸å¿ƒåˆçº¦ç»„æˆï¼š
1. **Factory åˆçº¦**ï¼š
   - ç®¡ç†æ‰€æœ‰äº¤æ˜“å¯¹
   - éƒ¨ç½²æ–°çš„äº¤æ˜“å¯¹
   - æ”¶å–åè®®è´¹ç”¨
   
2. **Pair åˆçº¦**ï¼š
   - å®ç° AMM æ ¸å¿ƒé€»è¾‘
   - ç®¡ç†ä»£å¸å‚¨å¤‡
   - å¤„ç†äº¤æ˜“å’ŒæµåŠ¨æ€§æ“ä½œ
   
3. **ERC20 åˆçº¦**ï¼š
   - å®ç° LP ä»£å¸æ ‡å‡†
   - æä¾› permit åŠŸèƒ½ï¼Œæ”¯æŒ gasless æˆæƒ

## 1. UniswapV2Factory.sol - å·¥å‚åˆçº¦

è¿™æ˜¯ Uniswap V2 çš„å·¥å‚åˆçº¦ï¼Œè´Ÿè´£åˆ›å»ºå’Œç®¡ç†äº¤æ˜“å¯¹ã€‚

```solidity
// æŒ‡å®š Solidity ç‰ˆæœ¬
pragma solidity =0.5.16;

// çŠ¶æ€å˜é‡
address public feeTo;        // æ”¶è´¹åœ°å€ - åè®®è´¹ç”¨æ¥æ”¶åœ°å€
address public feeToSetter;  // å¯ä»¥è®¾ç½®æ”¶è´¹åœ°å€çš„ç®¡ç†å‘˜åœ°å€ - æœ‰æƒæ›´æ”¹ feeTo åœ°å€çš„è´¦æˆ·

// å­˜å‚¨æ‰€æœ‰äº¤æ˜“å¯¹çš„åŒé‡æ˜ å°„
// ç¬¬ä¸€ä¸ª address æ˜¯ token0 åœ°å€
// ç¬¬äºŒä¸ª address æ˜¯ token1 åœ°å€
// å€¼æ˜¯å¯¹åº”çš„äº¤æ˜“å¯¹åˆçº¦åœ°å€
mapping(address => mapping(address => address)) public getPair;
address[] public allPairs;  // å­˜å‚¨æ‰€æœ‰å·²åˆ›å»ºçš„äº¤æ˜“å¯¹åœ°å€æ•°ç»„

// æ„é€ å‡½æ•°ï¼šè®¾ç½®åˆå§‹çš„ç®¡ç†å‘˜åœ°å€
// @param _feeToSetter åˆå§‹ç®¡ç†å‘˜åœ°å€
constructor(address _feeToSetter) public {
    feeToSetter = _feeToSetter;
}

// è¿”å›å½“å‰å·²åˆ›å»ºçš„äº¤æ˜“å¯¹æ€»æ•°
// @return äº¤æ˜“å¯¹æ€»æ•°
function allPairsLength() external view returns (uint) {
    return allPairs.length;
}

// æ ¸å¿ƒå‡½æ•°ï¼šåˆ›å»ºæ–°çš„äº¤æ˜“å¯¹
// @param tokenA ç¬¬ä¸€ä¸ªä»£å¸åœ°å€
// @param tokenB ç¬¬äºŒä¸ªä»£å¸åœ°å€
// @return pair æ–°åˆ›å»ºçš„äº¤æ˜“å¯¹åœ°å€
function createPair(address tokenA, address tokenB) external returns (address pair) {
    // æ£€æŸ¥ï¼šä¸¤ä¸ªä»£å¸åœ°å€ä¸èƒ½ç›¸åŒï¼Œé˜²æ­¢åˆ›å»ºæ— æ•ˆäº¤æ˜“å¯¹
    require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
    
    // å°†ä»£å¸åœ°å€æŒ‰å¤§å°æ’åºï¼Œç¡®ä¿ç›¸åŒçš„ä¸¤ä¸ªä»£å¸æ€»æ˜¯ä»¥ç›¸åŒçš„é¡ºåºåˆ›å»ºäº¤æ˜“å¯¹
    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
    
    // æ£€æŸ¥ï¼šä»£å¸åœ°å€ä¸èƒ½ä¸ºé›¶åœ°å€ï¼Œé˜²æ­¢åˆ›å»ºæ— æ•ˆäº¤æ˜“å¯¹
    require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
    
    // æ£€æŸ¥ï¼šè¯¥äº¤æ˜“å¯¹ä¸èƒ½å·²ç»å­˜åœ¨ï¼Œé˜²æ­¢é‡å¤åˆ›å»º
    require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS');
    
    // ä½¿ç”¨ CREATE2 æ“ä½œç åˆ›å»ºæ–°çš„äº¤æ˜“å¯¹åˆçº¦
    // CREATE2 å…è®¸æˆ‘ä»¬é¢„æµ‹åˆçº¦åœ°å€ï¼Œå¹¶ç¡®ä¿åœ°å€çš„ç¡®å®šæ€§
    bytes memory bytecode = type(UniswapV2Pair).creationCode;
    bytes32 salt = keccak256(abi.encodePacked(token0, token1));
    assembly {
        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
    }
    
    // åˆå§‹åŒ–æ–°åˆ›å»ºçš„äº¤æ˜“å¯¹åˆçº¦
    IUniswapV2Pair(pair).initialize(token0, token1);
    
    // æ›´æ–°çŠ¶æ€ï¼šè®°å½•äº¤æ˜“å¯¹æ˜ å°„å…³ç³»
    getPair[token0][token1] = pair;
    getPair[token1][token0] = pair; // åå‘æ˜ å°„ï¼Œæ–¹ä¾¿æŸ¥è¯¢
    allPairs.push(pair);  // å°†æ–°äº¤æ˜“å¯¹æ·»åŠ åˆ°æ•°ç»„ä¸­
    
    // è§¦å‘äº¤æ˜“å¯¹åˆ›å»ºäº‹ä»¶
    emit PairCreated(token0, token1, pair, allPairs.length);
}

// è®¾ç½®åè®®è´¹ç”¨æ¥æ”¶åœ°å€
// @param _feeTo æ–°çš„è´¹ç”¨æ¥æ”¶åœ°å€
function setFeeTo(address _feeTo) external {
    // åªæœ‰ feeToSetter å¯ä»¥è°ƒç”¨æ­¤å‡½æ•°
    require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
    feeTo = _feeTo;
}

// è½¬ç§»ç®¡ç†å‘˜æƒé™
// @param _feeToSetter æ–°çš„ç®¡ç†å‘˜åœ°å€
function setFeeToSetter(address _feeToSetter) external {
    // åªæœ‰å½“å‰ feeToSetter å¯ä»¥è½¬ç§»æƒé™
    require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
    feeToSetter = _feeToSetter;
}
```

## 2. UniswapV2ERC20.sol - ERC20 åŸºç¡€åˆçº¦

è¿™æ˜¯ Uniswap V2 çš„ LP ä»£å¸åˆçº¦ï¼Œå®ç°äº† ERC20 æ ‡å‡†å’Œ permit åŠŸèƒ½ã€‚

```solidity
// æŒ‡å®š Solidity ç‰ˆæœ¬
pragma solidity =0.5.16;

// ERC20 æ ‡å‡†ä»£å¸çŠ¶æ€å˜é‡
string public constant name = 'Uniswap V2';      // ä»£å¸åç§°
string public constant symbol = 'UNI-V2';        // ä»£å¸ç¬¦å·
uint8 public constant decimals = 18;             // å°æ•°ä½æ•°ï¼Œä¸ä»¥å¤ªåŠä¿æŒä¸€è‡´
uint public totalSupply;                         // ä»£å¸æ€»ä¾›åº”é‡
mapping(address => uint) public balanceOf;       // ç”¨æˆ·ä½™é¢æ˜ å°„ï¼šåœ°å€ => ä½™é¢
mapping(address => mapping(address => uint)) public allowance;  // æˆæƒæ˜ å°„ï¼šæ‰€æœ‰è€…åœ°å€ => (æˆæƒåœ°å€ => æˆæƒé‡‘é¢)

// EIP-2612 permit ç›¸å…³å˜é‡
bytes32 public DOMAIN_SEPARATOR;                 // EIP-712 åŸŸåˆ†éš”ç¬¦
// permit å‡½æ•°çš„ç±»å‹å“ˆå¸Œï¼Œç”¨äº EIP-712 ç­¾å
bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
mapping(address => uint) public nonces;          // ç”¨æˆ· nonce å€¼æ˜ å°„ï¼Œé˜²æ­¢é‡æ”¾æ”»å‡»

// å†…éƒ¨å‡½æ•°ï¼šé“¸é€ ä»£å¸
// @param to æ¥æ”¶æ–°é“¸é€ ä»£å¸çš„åœ°å€
// @param value é“¸é€ çš„ä»£å¸æ•°é‡
function _mint(address to, uint value) internal {
    totalSupply = totalSupply.add(value);        // å¢åŠ æ€»ä¾›åº”é‡
    balanceOf[to] = balanceOf[to].add(value);    // å¢åŠ æ¥æ”¶åœ°å€ä½™é¢
    emit Transfer(address(0), to, value);        // è§¦å‘è½¬è´¦äº‹ä»¶ï¼Œä»é›¶åœ°å€è½¬å‡ºè¡¨ç¤ºé“¸é€ 
}

// å†…éƒ¨å‡½æ•°ï¼šé”€æ¯ä»£å¸
// @param from é”€æ¯ä»£å¸çš„æ¥æºåœ°å€
// @param value é”€æ¯çš„ä»£å¸æ•°é‡
function _burn(address from, uint value) internal {
    balanceOf[from] = balanceOf[from].sub(value);  // å‡å°‘æ¥æºåœ°å€ä½™é¢
    totalSupply = totalSupply.sub(value);          // å‡å°‘æ€»ä¾›åº”é‡
    emit Transfer(from, address(0), value);        // è§¦å‘è½¬è´¦äº‹ä»¶ï¼Œè½¬å…¥é›¶åœ°å€è¡¨ç¤ºé”€æ¯
}

// å†…éƒ¨å‡½æ•°ï¼šæ›´æ–°æˆæƒé¢åº¦
// @param owner ä»£å¸æ‰€æœ‰è€…åœ°å€
// @param spender è¢«æˆæƒçš„åœ°å€
// @param value æˆæƒé‡‘é¢
function _approve(address owner, address spender, uint value) private {
    allowance[owner][spender] = value;           // æ›´æ–°æˆæƒé‡‘é¢
    emit Approval(owner, spender, value);        // è§¦å‘æˆæƒäº‹ä»¶
}

// å†…éƒ¨å‡½æ•°ï¼šæ‰§è¡Œè½¬è´¦
// @param from å‘é€æ–¹åœ°å€
// @param to æ¥æ”¶æ–¹åœ°å€
// @param value è½¬è´¦é‡‘é¢
function _transfer(address from, address to, uint value) private {
    balanceOf[from] = balanceOf[from].sub(value);  // å‡å°‘å‘é€æ–¹ä½™é¢
    balanceOf[to] = balanceOf[to].add(value);      // å¢åŠ æ¥æ”¶æ–¹ä½™é¢
    emit Transfer(from, to, value);                 // è§¦å‘è½¬è´¦äº‹ä»¶
}

// å¤–éƒ¨å‡½æ•°ï¼šæˆæƒä»£å¸
// @param spender è¢«æˆæƒçš„åœ°å€
// @param value æˆæƒé‡‘é¢
// @return æ˜¯å¦æˆæƒæˆåŠŸ
function approve(address spender, uint value) external returns (bool) {
    _approve(msg.sender, spender, value);
    return true;
}

// å¤–éƒ¨å‡½æ•°ï¼šè½¬è´¦ä»£å¸
// @param to æ¥æ”¶æ–¹åœ°å€
// @param value è½¬è´¦é‡‘é¢
// @return æ˜¯å¦è½¬è´¦æˆåŠŸ
function transfer(address to, uint value) external returns (bool) {
    _transfer(msg.sender, to, value);
    return true;
}

// å¤–éƒ¨å‡½æ•°ï¼šæˆæƒè½¬è´¦
// @param from å‘é€æ–¹åœ°å€
// @param to æ¥æ”¶æ–¹åœ°å€
// @param value è½¬è´¦é‡‘é¢
// @return æ˜¯å¦è½¬è´¦æˆåŠŸ
function transferFrom(address from, address to, uint value) external returns (bool) {
    // å¦‚æœæˆæƒé¢åº¦ä¸æ˜¯æœ€å¤§å€¼ï¼Œåˆ™éœ€è¦å‡å°‘æˆæƒé¢åº¦
    if (allowance[from][msg.sender] != uint(-1)) {
        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
    }
    _transfer(from, to, value);
    return true;
}

// EIP-2612 permit åŠŸèƒ½å®ç°
// å…è®¸ç”¨æˆ·é€šè¿‡ç­¾åæ¥æˆæƒï¼Œè€Œä¸éœ€è¦å‘é€äº¤æ˜“
// @param owner ä»£å¸æ‰€æœ‰è€…åœ°å€
// @param spender è¢«æˆæƒçš„åœ°å€
// @param value æˆæƒé‡‘é¢
// @param deadline ç­¾åçš„æœ‰æ•ˆæœŸ
// @param v ç­¾åçš„ v å€¼
// @param r ç­¾åçš„ r å€¼
// @param s ç­¾åçš„ s å€¼
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
    require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');  // æ£€æŸ¥ç­¾åæ˜¯å¦è¿‡æœŸ
    
    // è®¡ç®—æ¶ˆæ¯æ‘˜è¦
    bytes32 digest = keccak256(
        abi.encodePacked(
            '\x19\x01',                 // EIP-712 å‰ç¼€
            DOMAIN_SEPARATOR,           // åŸŸåˆ†éš”ç¬¦
            keccak256(abi.encode(      // å¯¹ç»“æ„åŒ–æ•°æ®è¿›è¡Œå“ˆå¸Œ
                PERMIT_TYPEHASH,       // ç±»å‹å“ˆå¸Œ
                owner,                 // æ‰€æœ‰è€…åœ°å€
                spender,              // è¢«æˆæƒåœ°å€
                value,                // æˆæƒé‡‘é¢
                nonces[owner]++,      // å½“å‰ nonce å€¼ï¼ˆä½¿ç”¨åè‡ªå¢ï¼‰
                deadline             // è¿‡æœŸæ—¶é—´
            ))
        )
    );
    
    // æ¢å¤ç­¾åè€…åœ°å€å¹¶éªŒè¯
    address recoveredAddress = ecrecover(digest, v, r, s);
    require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
    
    // æ‰§è¡Œæˆæƒ
    _approve(owner, spender, value);
}
```

## 3. UniswapV2Pair.sol - äº¤æ˜“å¯¹åˆçº¦

è¿™æ˜¯ Uniswap V2 çš„æ ¸å¿ƒäº¤æ˜“å¯¹åˆçº¦ï¼Œå®ç°äº† AMM çš„ä¸»è¦åŠŸèƒ½ã€‚

```solidity
// å¸¸é‡å’ŒçŠ¶æ€å˜é‡
uint public constant MINIMUM_LIQUIDITY = 10**3;  // æœ€å°æµåŠ¨æ€§æ•°é‡ï¼Œæ°¸ä¹…é”å®šåœ¨åˆçº¦ä¸­ï¼Œé˜²æ­¢é¦–æ¬¡æ·»åŠ æµåŠ¨æ€§æ—¶çš„ä»·æ ¼æ“çºµ
bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));  // ERC20 transfer å‡½æ•°é€‰æ‹©å™¨

address public factory;   // å·¥å‚åˆçº¦åœ°å€ï¼Œç”¨äºéªŒè¯è°ƒç”¨è€…æƒé™å’Œæ”¶å–åè®®è´¹ç”¨
address public token0;    // ä»£å¸0åœ°å€ï¼ŒæŒ‰åœ°å€å¤§å°æ’åºè¾ƒå°çš„ä»£å¸
address public token1;    // ä»£å¸1åœ°å€ï¼ŒæŒ‰åœ°å€å¤§å°æ’åºè¾ƒå¤§çš„ä»£å¸

uint112 private reserve0;           // ä»£å¸0çš„å½“å‰å‚¨å¤‡é‡ï¼Œä½¿ç”¨ uint112 ä»¥èŠ‚çœå­˜å‚¨ç©ºé—´
uint112 private reserve1;           // ä»£å¸1çš„å½“å‰å‚¨å¤‡é‡ï¼Œä½¿ç”¨ uint112 ä»¥èŠ‚çœå­˜å‚¨ç©ºé—´
uint32 private blockTimestampLast; // æœ€åæ›´æ–°å‚¨å¤‡é‡çš„åŒºå—æ—¶é—´æˆ³ï¼Œç”¨äºè®¡ç®— TWAP

// ä»·æ ¼ç´¯ç§¯å˜é‡ï¼Œç”¨äºè®¡ç®— TWAPï¼ˆæ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼ï¼‰
uint public price0CumulativeLast;  // token0 ç›¸å¯¹äº token1 çš„ä»·æ ¼ç´¯ç§¯å€¼
uint public price1CumulativeLast;  // token1 ç›¸å¯¹äº token0 çš„ä»·æ ¼ç´¯ç§¯å€¼
uint public kLast;  // æœ€åä¸€æ¬¡æµåŠ¨æ€§å˜åŠ¨æ—¶çš„ k å€¼ï¼ˆreserve0 * reserve1ï¼‰ï¼Œç”¨äºè®¡ç®—åè®®è´¹ç”¨

// é‡å…¥é”ï¼Œé˜²æ­¢é‡å…¥æ”»å‡»
uint private unlocked = 1;
modifier lock() {
    require(unlocked == 1, 'UniswapV2: LOCKED');
    unlocked = 0;
    _;
    unlocked = 1;
}

// æ ¸å¿ƒåŠŸèƒ½ï¼šæ·»åŠ æµåŠ¨æ€§
// @param to LP ä»£å¸æ¥æ”¶åœ°å€
// @return liquidity é“¸é€ çš„ LP ä»£å¸æ•°é‡
function mint(address to) external lock returns (uint liquidity) {
    // è·å–å½“å‰å‚¨å¤‡é‡å’Œå®é™…ä½™é¢
    (uint112 _reserve0, uint112 _reserve1,) = getReserves();
    uint balance0 = IERC20(token0).balanceOf(address(this));
    uint balance1 = IERC20(token1).balanceOf(address(this));
    // è®¡ç®—æ–°å¢çš„ä»£å¸æ•°é‡
    uint amount0 = balance0.sub(_reserve0);
    uint amount1 = balance1.sub(_reserve1);

    // å¤„ç†åè®®è´¹ç”¨ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    bool feeOn = _mintFee(_reserve0, _reserve1);
    
    // è®¡ç®—åº”é“¸é€ çš„ LP ä»£å¸æ•°é‡
    uint _totalSupply = totalSupply;
    if (_totalSupply == 0) {
        // é¦–æ¬¡æ·»åŠ æµåŠ¨æ€§ï¼šä½¿ç”¨å‡ ä½•å¹³å‡æ•°
        liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
        _mint(address(0), MINIMUM_LIQUIDITY);  // æ°¸ä¹…é”å®šæœ€å°æµåŠ¨æ€§
    } else {
        // éé¦–æ¬¡æ·»åŠ ï¼šå–ä¸¤ä¸ªä»£å¸æŠ•å…¥æ¯”ä¾‹çš„è¾ƒå°å€¼
        liquidity = Math.min(
            amount0.mul(_totalSupply) / _reserve0,
            amount1.mul(_totalSupply) / _reserve1
        );
    }
    
    // éªŒè¯å¹¶é“¸é€  LP ä»£å¸
    require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
    _mint(to, liquidity);

    // æ›´æ–°å‚¨å¤‡é‡
    _update(balance0, balance1, _reserve0, _reserve1);
    // å¦‚æœå¯ç”¨äº†åè®®è´¹ç”¨ï¼Œæ›´æ–° kLast
    if (feeOn) kLast = uint(reserve0).mul(reserve1);
    emit Mint(msg.sender, amount0, amount1);
}

// æ ¸å¿ƒåŠŸèƒ½ï¼šç§»é™¤æµåŠ¨æ€§
// @param to ä»£å¸æ¥æ”¶åœ°å€
// @return amount0 è¿”è¿˜çš„ token0 æ•°é‡
// @return amount1 è¿”è¿˜çš„ token1 æ•°é‡
function burn(address to) external lock returns (uint amount0, uint amount1) {
    // è·å–å½“å‰å‚¨å¤‡é‡å’Œå®é™…ä½™é¢
    (uint112 _reserve0, uint112 _reserve1,) = getReserves();
    address _token0 = token0;
    address _token1 = token1;
    uint balance0 = IERC20(_token0).balanceOf(address(this));
    uint balance1 = IERC20(_token1).balanceOf(address(this));
    uint liquidity = balanceOf[address(this)];  // è¦é”€æ¯çš„ LP ä»£å¸æ•°é‡

    // å¤„ç†åè®®è´¹ç”¨ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    bool feeOn = _mintFee(_reserve0, _reserve1);
    
    // è®¡ç®—åº”è¿”è¿˜çš„ä»£å¸æ•°é‡
    uint _totalSupply = totalSupply;
    amount0 = liquidity.mul(balance0) / _totalSupply;
    amount1 = liquidity.mul(balance1) / _totalSupply;
    
    // éªŒè¯å¹¶æ‰§è¡Œé”€æ¯å’Œè½¬è´¦
    require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
    _burn(address(this), liquidity);
    _safeTransfer(_token0, to, amount0);
    _safeTransfer(_token1, to, amount1);
    
    // æ›´æ–°å‚¨å¤‡é‡
    balance0 = IERC20(_token0).balanceOf(address(this));
    balance1 = IERC20(_token1).balanceOf(address(this));
    _update(balance0, balance1, _reserve0, _reserve1);
    // å¦‚æœå¯ç”¨äº†åè®®è´¹ç”¨ï¼Œæ›´æ–° kLast
    if (feeOn) kLast = uint(reserve0).mul(reserve1);
    emit Burn(msg.sender, amount0, amount1, to);
}

// æ ¸å¿ƒåŠŸèƒ½ï¼šä»£å¸äº¤æ¢
// @param amount0Out è¾“å‡ºçš„ token0 æ•°é‡
// @param amount1Out è¾“å‡ºçš„ token1 æ•°é‡
// @param to ä»£å¸æ¥æ”¶åœ°å€
// @param data å›è°ƒæ•°æ®ï¼Œç”¨äºé—ªç”µè´·
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
    // åŸºæœ¬æ£€æŸ¥ï¼šè‡³å°‘æœ‰ä¸€ä¸ªè¾“å‡ºæ•°é‡å¤§äº 0
    require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
    (uint112 _reserve0, uint112 _reserve1,) = getReserves();
    // æ£€æŸ¥ï¼šè¾“å‡ºæ•°é‡ä¸èƒ½è¶…è¿‡å‚¨å¤‡é‡
    require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');

    // æ‰§è¡Œäº¤æ¢
    uint balance0;
    uint balance1;
    {
        address _token0 = token0;
        address _token1 = token1;
        // æ£€æŸ¥ï¼šæ¥æ”¶åœ°å€ä¸èƒ½æ˜¯ä»£å¸åœ°å€
        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
        // è½¬ç§»ä»£å¸ç»™æ¥æ”¶åœ°å€
        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);
        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);
        // å¦‚æœæä¾›äº†å›è°ƒæ•°æ®ï¼Œæ‰§è¡Œé—ªç”µè´·å›è°ƒ
        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
        // è·å–äº¤æ˜“åçš„ä½™é¢
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));
    }

    // è®¡ç®—å®é™…çš„è¾“å…¥é‡‘é¢
    uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
    uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
    // æ£€æŸ¥ï¼šè‡³å°‘æœ‰ä¸€ä¸ªè¾“å…¥é‡‘é¢å¤§äº 0
    require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');

    // éªŒè¯ K å€¼ï¼šç¡®ä¿äº¤æ˜“åçš„ K å€¼ä¸å°äºäº¤æ˜“å‰
    {
        // åº”ç”¨ 0.3% æ‰‹ç»­è´¹åçš„ä½™é¢
        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
    }

    // æ›´æ–°å‚¨å¤‡é‡
    _update(balance0, balance1, _reserve0, _reserve1);
    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
}

// è¾…åŠ©åŠŸèƒ½ï¼šå¼ºåˆ¶å¹³è¡¡
// å°†è¶…é¢ä»£å¸è½¬ç§»åˆ°æŒ‡å®šåœ°å€ï¼Œç”¨äºä¿®å¤é”™è¯¯è½¬è´¦
// @param to æ¥æ”¶åœ°å€
function skim(address to) external lock {
    address _token0 = token0;
    address _token1 = token1;
    _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
    _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
}

// è¾…åŠ©åŠŸèƒ½ï¼šåŒæ­¥å‚¨å¤‡é‡
// å°†å‚¨å¤‡é‡æ›´æ–°ä¸ºå½“å‰å®é™…ä½™é¢
function sync() external lock {
    _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
}
```

è¿™äº›åˆçº¦å…±åŒæ„æˆäº† Uniswap V2 çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œå®ç°äº†å»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€çš„ä¸»è¦ç‰¹æ€§ï¼š
1. è‡ªåŠ¨åšå¸‚å•†ï¼ˆAMMï¼‰æœºåˆ¶
2. æµåŠ¨æ€§æä¾›å’Œç§»é™¤
3. ä»£å¸äº¤æ¢
4. ä»·æ ¼é¢„è¨€æœºåŠŸèƒ½
5. åè®®è´¹ç”¨æœºåˆ¶
6. é—ªç”µè´·åŠŸèƒ½

æ¯ä¸ªåˆçº¦éƒ½æœ‰å…¶ç‰¹å®šçš„èŒè´£ï¼š
- Factory åˆçº¦è´Ÿè´£åˆ›å»ºå’Œç®¡ç†äº¤æ˜“å¯¹
- ERC20 åˆçº¦æä¾›æ ‡å‡†ä»£å¸åŠŸèƒ½å’Œ permit ç‰¹æ€§
- Pair åˆçº¦å®ç°æ ¸å¿ƒçš„ AMM é€»è¾‘å’Œäº¤æ˜“åŠŸèƒ½ 
